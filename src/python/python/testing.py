from __future__ import annotations # Delayed parsing of type annotations
import sys, os, inspect
from os.path import abspath, dirname, join, exists
from typing import Union

import drjit as dr
import mitsuba as mi

class RenderingRegressionTest:
    '''
    A rendering regression test is a test case that compares a rendered image
    against a reference image. The test is based on the Z-test, using the `moment`
    integrator to compute the first and second moments of the image. The test
    is successful if the null hypothesis (that the images are identical) cannot
    be rejected at the given significance level.

    Reference images can be generated by running pytest with the argument `--generate_ref`
    '''

    def __init__(self,
                 name: str,
                 scene: mi.Scene,
                 sensor: Union[int, mi.Sensor] = 0,
                 test_spp=512,
                 ref_spp=8192,
                 significance_level=0.01,
                 pixel_success_rate=0.975,
                 references_folder=None,
                 generate_ref: bool=False):
        '''
        Create a rendering regression test.

        Arguments:
            name: Name of the test case
            scene: Scene dictionary
            sensor: Sensor to use for rendering
            test_spp: Number of samples per pixel to use for the test
            ref_spp:  Number of samples per pixel to use for the reference image
            significance_level: Significance level of the test
            pixel_success_rate: Minimum pixel success rate
            references_folder: Path to where to store the generated reference images. If not specified, put in 'references' folder next to the test script.
            options: Options dictionary
        '''
        self.name = name
        self.scene = scene
        self.sensor = sensor
        self.test_spp = test_spp
        self.ref_spp = ref_spp
        self.significance_level = significance_level
        self.pixel_success_rate = pixel_success_rate
        self.references_folder = references_folder
        if self.references_folder is None:
            # Look at the caller's stack and scope
            caller_stack = inspect.stack()[1][0]
            caller_script_dir = dirname(abspath(caller_stack.f_code.co_filename))
            self.references_folder = join(caller_script_dir, 'references')

        if generate_ref:
            self.render_reference()

    def render_reference(self):
        '''
        Render a reference image for the test case
        '''
        print("=> Render reference images")

        # Load the scene
        if self.scene.integrator().class_name() != "MomentIntegrator":
            raise Exception('RenderingRegressionTest expects the scene to use the `moment` integrator!')

        # Render reference image
        img = mi.render(self.scene, sensor=self.sensor, spp=self.ref_spp)
        dr.eval(img)

        # Extract first and second moments
        m1 = img[:, :, 0:3]
        m2 = img[:, :, 3:6]

        # Compute RGB image and variance image
        rgb = m1
        var = m2 - m1 * m1

        # Write reference images to disk
        mi.Bitmap(rgb).write(self._filename('img'))
        mi.Bitmap(var).write(self._filename('var'))

    def run(self) -> bool:
        '''
        Run the test case
        '''
        if not exists(self._filename('img')) or not self._filename('var'):
            raise Exception("RenderingRegressionTest: missing reference images! "
                            "You should run pytest with the `--generate_ref` "
                            "argument to generate the reference images.")

        # Load reference images
        ref_img = mi.TensorXf(mi.Bitmap(self._filename('img')))
        ref_var = mi.TensorXf(mi.Bitmap(self._filename('var')))

        # Load the scene
        if self.scene.integrator().class_name() != "MomentIntegrator":
            raise Exception('RenderingRegressionTest: expects the scene to use the `moment` integrator!')

        # Render image
        img = mi.render(self.scene, sensor=self.sensor, spp=self.test_spp)[:, :, 0:3]

        # Compute Z statistic
        z_stat = dr.abs(img - ref_img) * dr.sqrt(self.test_spp / dr.maximum(ref_var, 1e-4))

        # Cumulative distribution function of the standard normal distribution
        values = (1.0 - dr.erf(-z_stat.array / dr.sqrt(2.0))) * 0.5
        cdf = mi.TensorXf(values, z_stat.shape)

        # Compute p-value
        p_value = 2.0 * (1.0 - cdf)

        # Apply the Sidak correction term, since we'll be conducting multiple independent
        # hypothesis tests. This accounts for the fact that the probability of a failure
        # increases quickly when several hypothesis tests are run in sequence.
        pixel_count = ref_img.shape[0] * ref_img.shape[1]
        alpha = 1.0 - (1.0 - self.significance_level) ** (1.0 / pixel_count)
        success = (p_value > alpha)

        if (dr.count(success.array) / 3.0) >= (self.pixel_success_rate * pixel_count):
            print('Accepted the null hypothesis (min(p-value) = %f, significance level = %f)' %
                  (dr.slice(dr.min(p_value.array)), alpha))
            return True
        else:
            print('Reject the null hypothesis (min(p-value) = %f, significance level = %f)' %
                  (dr.slice(dr.min(p_value.array)), alpha))

            print(f'=> Successful pixel count {dr.count(success.array) / 3.0} vs {self.pixel_success_rate * pixel_count} (expected)')

            filename = self._filename('pvalue')
            print(f'=> Write p-value image to {filename}')
            mi.Bitmap(p_value).write(filename)

            filename = self._filename('success')
            print(f'=> Write success image to {filename}')
            mi.Bitmap(dr.select(success, 1.0, 0.0)).write(filename)

            filename = self._filename('image')
            print(f'=> Write image to {filename}')
            mi.Bitmap(img).write(filename)

            return False

    def _filename(self, suffix):
        '''
        Return the filename of a reference image for this test case with the given suffix.

        The reference image is stored in a `references` folder in the same
        directory as the caller's script.
        '''
        os.makedirs(self.references_folder, exist_ok=True)
        return join(self.references_folder, f'{self.name}_{suffix}.exr')

    def __repr__(self):
        return self.name
