from collections import OrderedDict
import json
import re
import os
from os.path import join, dirname, realpath
try:
    from io import StringIO
except ImportError:
    from StringIO import StringIO

def write_core_config(f, enabled, default_mode):
    def w(s):
        f.write(s.ljust(79) + ' \\\n')

    f.write('/* This file is automatically generated from "mitsuba.conf" using the script\n')
    f.write('   "resources/configure.py". Please do not attempt to change it manually,\n')
    f.write('   as any changes will be overwritten. The main purpose of this file is to\n')
    f.write('   helper various macros to instantiate multiple variants of Mitsuba. */\n\n')

    f.write('#pragma once\n\n')
    f.write('#include <mitsuba/core/fwd.h>\n\n')

    f.write('/// List of enabled Mitsuba variants\n')
    w('#define MTS_VARIANTS')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    "%s\\n"' % name)
    f.write('\n\n')

    f.write('/// Default variant to be used by the "mitsuba" executable\n')
    w('#define MTS_DEFAULT_VARIANT "%s"' % default_mode)
    f.write('\n\n')

    f.write('/// Declare that a "struct" template is to be imported and not instantiated\n')
    w('#define MTS_EXTERN_STRUCT(Name)')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    extern template struct MTS_EXPORT Name<%s, %s>;' % (float_, spectrum))
    f.write('\n\n')

    f.write('/// Declare that a "class" template is to be imported and not instantiated\n')
    w('#define MTS_EXTERN_CLASS(Name)')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    extern template class MTS_EXPORT Name<%s, %s>;' % (float_, spectrum))
    f.write('\n\n')

    f.write('/// Explicitly instantiate all variants of a "struct" template\n')
    w('#define MTS_INSTANTIATE_STRUCT(Name)')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    template struct MTS_EXPORT Name<%s, %s>;' % (float_, spectrum))
    f.write('\n\n')

    f.write('/// Explicitly instantiate all variants of a "class" template\n')
    w('#define MTS_INSTANTIATE_CLASS(Name)')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    template class MTS_EXPORT Name<%s, %s>;' % (float_, spectrum))
    f.write('\n\n')

    f.write('/// Call the variant function "func" for a specific variant "variant"\n')
    w('#define MTS_INVOKE_VARIANT(variant, func, ...)')
    w('    [&]() {')
    for index, (name, float_, spectrum) in enumerate(enabled):
        iff = 'if' if index == 0 else 'else if'
        w('        %s (variant == "%s")' % (iff, name))
        w('            return func<%s, %s>(__VA_ARGS__);' % (float_, spectrum))
    w('        else')
    w('            Throw("Unsupported variant: %s", variant);')
    w('    }()')
    f.write('\n\n')

    f.write('NAMESPACE_BEGIN(mitsuba)\n')
    f.write('NAMESPACE_BEGIN(detail)\n')
    f.write('/// Convert a <Float, Spectrum> type pair into one of the strings in MTS_VARIANT\n')
    f.write('template <typename Float_, typename Spectrum_> constexpr const char *get_variant() {\n')
    for index, (name, float_, spectrum) in enumerate(enabled):
        f.write('    %sif constexpr (std::is_same_v<Float_, %s> &&\n' % ('else ' if index > 0 else '', float_))
        f.write('    %s              std::is_same_v<Spectrum_, %s>)\n' % ('     ' if index > 0 else '', spectrum))
        f.write('        return "%s";\n' % name)
    f.write('    else\n')
    f.write('        return "";\n')
    f.write('}\n')
    f.write('NAMESPACE_END(detail)\n')
    f.write('NAMESPACE_END(mitsuba)\n')


def write_python_config(f, enabled, float_types):
    def w(s):
        f.write(s.ljust(79) + ' \\\n')

    f.write('#pragma once\n\n')
    f.write('#include <mitsuba/core/fwd.h>\n\n')

    f.write('/// Declare a pybind11 extern binding function for a set of bindings under a given name\n')
    w('#define MTS_PY_DECLARE(name)')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    extern void python_export_%s_##name(py::module &);' % (name))
    f.write('\n\n')

    f.write('/// Define a python submodule for each rendering mode\n')
    w('#define MTS_PY_DEF_SUBMODULE(list, lib)')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    auto __submodule__%s =  m.def_submodule("%s").def_submodule(#lib);' % (name, name))
        w('    list.push_back(__submodule__%s);' % name)
    f.write('\n\n')

    f.write('/// Execute the pybind11 binding function for a set of bindings under a given name\n')
    w('#define MTS_PY_IMPORT(name)')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    python_export_%s_##name(__submodule__%s);' % (name, name))
    f.write('\n\n')

    f.write('/// Define the pybind11 binding function for a set of bindings under a given name\n')
    w('#define MTS_PY_EXPORT(name)')
    w('    template <typename Float, typename Spectrum>')
    w('    void instantiate_##name(py::module m);')
    w('')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    void python_export_%s_##name(py::module &m) {' % (name))
        w('        instantiate_##name<%s, %s>(m);' % (float_, spectrum))
        w('    }')
    w('')
    w('    template <typename Float, typename Spectrum>')
    w('    void instantiate_##name(py::module m)')
    f.write('\n\n')

    f.write('/// Define the pybind11 binding function for a structures under a given name\n')
    w('#define MTS_PY_EXPORT_STRUCT(name)')
    w('    template <typename Float, typename Spectrum>')
    w('    void instantiate_##name(py::module m);')
    w('')
    for index, (name, float_, spectrum) in enumerate(enabled):
        w('    void python_export_%s_##name(py::module &m) {' % (name))
        if float_.startswith('Packet'):
            float_x = 'DynamicArray<%s>' % float_
            spectrum = spectrum.replace(float_, float_x)
            float_ = float_x
        w('        instantiate_##name<%s, %s>(m);' % (float_, spectrum))
        w('    }')
    w('')
    w('    template <typename Float, typename Spectrum>')
    w('    void instantiate_##name(py::module m)')
    f.write('\n\n')

    f.write('/// Cast an Object pointer (\'o\') to the corresponding python object\n')
    w('#define PY_CAST_OBJECT(Type)')
    w('    if (auto tmp = dynamic_cast<Type *>(o); tmp)')
    w('        return py::cast(tmp, py::return_value_policy::reference);')
    f.write('\n\n')

    f.write('/// Cast any variants of an Object pointer to the corresponding python object\n')
    w('#define PY_CAST_OBJECT_VARIANTS(Name)')
    for index, (name, float_, spectrum) in enumerate(enabled):
        spectrum = spectrum.replace('Float', float_)
        w('    PY_CAST_OBJECT(PYBIND11_TYPE(Name<%s, %s>))' % (float_, spectrum))
    f.write('\n\n')

    f.write('/// Cast a void pointer (\'ptr\') to the corresponding python object given a std::type_info \'type\'\n')
    w('#define PY_CAST(Type)')
    w('    if (std::string(type.name()) == std::string(typeid(Type).name()))')
    w('        return py::cast(static_cast<Type *>(ptr), py::return_value_policy::reference);')
    f.write('\n\n')

    f.write('/// Cast any variants of a void pointer (\'ptr\') to the corresponding python object\n')
    w('#define PY_CAST_VARIANTS(Type)')
    for index, float_ in enumerate(float_types):
        w('    PY_CAST(PYBIND11_TYPE(typename CoreAliases<%s>::Type))' % (float_))
    f.write('\n\n')

def write_to_file_if_changed(filename, contents):
    '''Writes the given contents to file, only if they do not already match.'''
    if os.path.isfile(filename):
        with open(filename, 'r') as f:
            existing = f.read()
            if existing == contents:
                return False

    with open(filename, 'w') as f:
        f.write(contents)
    print('Generated configuration header: ' + filename)


if __name__ == '__main__':
    root = realpath(dirname(dirname(__file__)))

    with open(join(root, 'mitsuba.conf'), 'r') as conf:
        # Strip comments
        s = re.sub(re.compile(r'(?m)^ *#.*\n?'), '', conf.read())
        # Load JSON
        configurations = json.loads(s)

    # Let's start with some validation
    assert 'enabled' in configurations and 'default' in configurations
    assert isinstance(configurations['default'], str)
    assert isinstance(configurations['enabled'], list)

    # Extract enabled configurations
    enabled = []
    float_types = set()
    for name in configurations['enabled']:
        if name not in configurations:
            raise ValueError('"enabled" refers to an unknown configuration "%s"' % name)
        item = configurations[name]
        spectrum = item['spectrum'].replace('Float', item['float'])
        float_types.add(item['float'])
        enabled.append((name, item['float'], spectrum))

    if not enabled:
        raise ValueError('There must be at least one enabled build configuration!')

    # Use first configuration if default mode is not specified
    default_mode = configurations.get('default', enabled[0][0])

    fname = realpath(join(root, 'include/mitsuba/core/config.h'))
    output = StringIO()
    write_core_config(output, enabled, default_mode)
    write_to_file_if_changed(fname, output.getvalue())

    fname = realpath(join(root, 'include/mitsuba/python/config.h'))
    output = StringIO()
    write_python_config(output, enabled, float_types)
    write_to_file_if_changed(fname, output.getvalue())
